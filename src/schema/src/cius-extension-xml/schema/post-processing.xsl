<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://xmlguru.cz/xslt/functions"
  xmlns:temp="http://xmlguru.cz/ns/temp/trang-post-processing"
  xmlns:doc="http://xmlguru.cz/ns/doc"  
  exclude-result-prefixes="xs temp f doc"
  version="2.0">

  <doc:doc scope="stylesheet">		
    <doc:desc>
      <doc:p>Applies changes to the XSD files generated from RELAX NG by Trang.
        Transformation is not completely generic, if more radical changes are made in RELAX NG sources, some adjustment might be needed.</doc:p>
      <doc:p>Top level XSD schema generated by Trang should be supplied as a primary input source.</doc:p>
      <doc:p>Output is written into the current directory.</doc:p>
      <doc:p>Transformation tries to do several things:</doc:p>
      <doc:ul>
        <doc:li>remove substitution groups</doc:li>
        <doc:li>remove some constructs that break UPA rules</doc:li>
        <doc:li>redesign schema from "salami slices" design to more "venetian blinds"-like (although this is limited as schema uses several namespaces that reference each other)</doc:li>
        <doc:li>for each element "foo" there is a corresponding type "fooType" (in the same targetNamespace)</doc:li>
        <doc:li>additional schema that imports schemas for all target namespaces is created as well</doc:li>
        <doc:li>XML comments are turned into xs:annotation/xs:documentation elements</doc:li>
      </doc:ul>
    </doc:desc>
  </doc:doc>

  <xsl:strip-space elements="*"/>
  <xsl:preserve-space elements="xs:documentation"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Key for quick lookup of element declarations</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:key name="elements" match="xs:element[@name]" 
    use="QName((ancestor::xs:schema/@targetNamespace, '')[1], @name)"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Key for quick lookup of substitution groups</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:key name="substitution-groups" match="temp:substitution-group[@name]" 
    use="resolve-QName(@name, .)"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Key for quick lookup of references to element declarations</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:key name="element-refs" match="xs:element[@ref]"
           use="resolve-QName(@ref, .)"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Key for quick lookup of elements belonging to a particular substitution group</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:key name="elements-in-sg" match="xs:element[@substitutionGroup]"
    use="resolve-QName(@substitutionGroup, .)"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds list of URIs for all files where schema is stored (please note that XSD requires separate file for each namespace)</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-uris" as="xs:string*">
    <xsl:variable name="raw" as="xs:string*">
    <xsl:apply-templates select="/" 
                         mode="get-schema-uris"/>
    </xsl:variable>
    <xsl:sequence select="distinct-values($raw)"/>  
  </xsl:variable>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds sequence of all loaded schema files.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema">
    <xsl:message>Loading schema files from:</xsl:message>
    <xsl:for-each select="$schema-uris">
      <xsl:message><xsl:value-of select="."/></xsl:message>
      <xsl:copy-of select="doc(.)"/>
    </xsl:for-each>
  </xsl:variable>
  
  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds sequence of all loaded schema files with substitution groups replaced by another constructs.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-without-substitution-groups">
    <xsl:apply-templates select="$schema" mode="replace-substitution-groups"/>
  </xsl:variable>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds sequence of all loaded schema files with substitution groups replaced by another constructs and improved adherance to UPA rules.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-without-broken-upa">
    <xsl:apply-templates select="$schema-without-substitution-groups" mode="remove-upa"/>
  </xsl:variable>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds sequence of all loaded schema files with substitution groups replaced by another constructs, improved adherance to UPA rules and comments turned into XSD annotations.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-with-annotations">
    <xsl:apply-templates select="$schema-without-broken-upa" mode="comments-to-annotations"/>
  </xsl:variable>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Variable holds sequence of all loaded schema files with substitution groups replaced by another constructs, improved adherance to UPA rules, comments turned into XSD annotations and removed as much as possible "salami slice" design.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-without-slices">
    <xsl:apply-templates select="$schema-with-annotations" mode="remove-slices"/>
  </xsl:variable>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>variable holds cleanup version of schemas</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="schema-without-temp-ns">
    <xsl:apply-templates select="$schema-without-slices" mode="remove-temp-ns"/>
  </xsl:variable>
  
  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>List of names of substitution groups used in the schemas.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="substitution-groups-names" select="$schema//*[@substitutionGroup]/resolve-QName(@substitutionGroup, .)"/>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Temporary tree holding replacement for all substitution groups found.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:variable name="substitution-groups">
    <xsl:message>Detecting substitution groups...</xsl:message>
    <xsl:for-each-group select="$substitution-groups-names" group-by=".">
      <xsl:variable name="elements-in-group" select="$schema//*[resolve-QName(@substitutionGroup, .) = current()]"/>
      <temp:substitution-group name="{.}" namespace="{namespace-uri-from-QName(.)}">
        <xsl:namespace name="{prefix-from-QName(.)}" select="namespace-uri-from-QName(.)"/>
        <xsl:variable name="namespace" select="namespace-uri-from-QName(.)"/>
        <xsl:choose>
          <!-- If there is only one element in the substituion group, just remove substitution group -->
          <xsl:when test="count($elements-in-group) = 1">
            <xsl:message>Removing substitution group <xsl:value-of select="."/>. Only one declaration is in group.</xsl:message>
            <xsl:apply-templates select="$elements-in-group[not(@abstract = 'true')]"
                                 mode="remove-substitution-group-attribute">
              <xsl:with-param name="tns" select="$namespace"/>
            </xsl:apply-templates>
            <!-- Handle abstract elements that are substituted from the another direction  -->
            <xsl:for-each select="$elements-in-group[@abstract = 'true']">
              <xsl:apply-templates select="key('elements-in-sg', QName(ancestor::xs:schema/@targetNamespace, @name), $schema)"
                                   mode="remove-substitution-group-attribute">
                <xsl:with-param name="tns" select="$namespace"/>
              </xsl:apply-templates>                  
            </xsl:for-each>
          </xsl:when>
          <!-- If there are more elements, replace them with xs:choice (and don't include abstract elements into xs:choice) -->
          <xsl:otherwise>
            <xsl:message>Replacing substitution group <xsl:value-of select="."/> by xs:choice inside normal group.</xsl:message>
            <xs:group name="{local-name-from-QName(.)}">              
              <xs:choice>
                <xsl:apply-templates select="$elements-in-group[not(@abstract = 'true')]"
                                     mode="remove-substitution-group-attribute">
                  <xsl:with-param name="tns" select="$namespace"/>
                </xsl:apply-templates>
                <!-- Handle abstract elements that are substituted from the another direction  -->
                <xsl:for-each select="$elements-in-group[@abstract = 'true']">
                  <xsl:apply-templates select="key('elements-in-sg', QName(ancestor::xs:schema/@targetNamespace, @name), $schema)"
                                       mode="remove-substitution-group-attribute">
                    <xsl:with-param name="tns" select="$namespace"/>
                  </xsl:apply-templates>                  
                </xsl:for-each>
              </xs:choice>              
            </xs:group>
          </xsl:otherwise>
        </xsl:choose>
      </temp:substitution-group>
    </xsl:for-each-group>
  </xsl:variable>

  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for removing substitutionGroup attribute from element declarations</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="remove-substitution-group-attribute">
    <xsl:copy>
      <xsl:copy-of select="@* except @substitutionGroup"/>
      <xsl:apply-templates mode="remove-substitution-group-attribute"/>
    </xsl:copy>
  </xsl:template>

  <!-- For elements that do not have type definition but are members of substitution group, we must copy type definition from substitution group head -->
  <!-- Also if element is in the different namespace, we have just to reference it -->
  <xsl:template match="xs:element[not(@type) and not(xs:complexType|xs:simpleType) and @substitutionGroup]" mode="remove-substitution-group-attribute">
    <xsl:param name="tns"/>
    
    <xsl:variable name="namespace" select="ancestor::xs:schema/@targetNamespace"/>
    <xsl:variable name="local-name" select="@name"/>
    <xsl:variable name="prefix" select="ancestor::xs:schema/namespace::*[. = $namespace]/name()"/>
    <xsl:copy>
      <xsl:copy-of select="@* except @substitutionGroup"/>
      <!-- For elements in different target namespace we are keeping @ref around to be used later in the process -->
      <xsl:if test="$namespace != $tns">
        <xsl:message>Substituting <xsl:value-of select="@name"/> by reference to <xsl:value-of select="concat($prefix, ':', $local-name)"/></xsl:message>
        <xsl:namespace name="{$prefix}" select="$namespace"/>
        <xsl:attribute name="override-with-ref" select="concat($prefix, ':', $local-name)"/>            
      </xsl:if>
      <xsl:call-template name="copy-type">
        <xsl:with-param name="qname" select="resolve-QName(@substitutionGroup, .)"/>
      </xsl:call-template>
    </xsl:copy>        
  </xsl:template>

  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for replacing substitution groups by another constructs</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="replace-substitution-groups">
    <xsl:copy>
      <xsl:copy-of select="@* except @override-with-ref"/>
      <xsl:apply-templates mode="replace-substitution-groups"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- Abstract elements are no longer needed -->
  <xsl:template match="xs:element[@abstract='true' and @substitutionGroup]" mode="replace-substitution-groups" priority="10"/>

  <xsl:template match="xs:element[@ref]" mode="replace-substitution-groups" priority="5">
    <xsl:variable name="sg" select="key('substitution-groups', resolve-QName(@ref, .), $substitution-groups)"/>
    
    <xsl:choose>
      <!-- If element points to substitution group, replace it with reference to this group -->
      <xsl:when test="$sg/xs:group">
        <xsl:choose>
          <xsl:when test="$sg/@namespace = ancestor::xs:schema/@targetNamespace">
            <xs:group>
              <xsl:copy-of select="@*"/>
            </xs:group>
          </xsl:when>
          <xsl:otherwise>
            <xsl:message terminate="yes">Group placed into wrong target namespace: <xsl:value-of select="$sg/@name"/></xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$sg/xs:element[@override-with-ref]">
        <xs:element ref="{$sg/xs:element/@override-with-ref}">
          <xsl:copy-of select="@minOccurs, @maxOccurs"/>
        </xs:element>
      </xsl:when>
      <xsl:when test="$sg/xs:element">
        <xsl:copy-of select="$sg/xs:element"/>
      </xsl:when>
      <!-- If element doesn't point to substitution group, keep going -->
      <xsl:otherwise>
        <xsl:copy>
          <xsl:copy-of select="@*"/>
          <xsl:apply-templates mode="replace-substitution-groups"/>
        </xsl:copy>        
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Special handling for element declarations that are in a substitution group -->
  <xsl:template match="xs:element[@substitutionGroup]" mode="replace-substitution-groups" priority="5">
    <xsl:variable name="sg-qname" select="resolve-QName(@substitutionGroup, .)"/>
    <xsl:variable name="sg" select="key('substitution-groups', $sg-qname, $substitution-groups)"/>
    
    <xsl:choose>
      <!-- If we are at the first occurence of particular sub. group we replace element declaration with corresponding xs:group/xs:element -->
      <xsl:when test="$sg and not(preceding-sibling::xs:element[resolve-QName(@substitutionGroup, .) = $sg-qname])">
        <xsl:apply-templates select="$sg/node()" mode="replace-substitution-groups"/>
      </xsl:when>
      <!-- For another occurences we just copy element declaration and remove @substitutionGroup 
           (this is necessary as some of such elements must be kept global to be referencable from schemas with another target namespace -->
      <xsl:when test="$sg">
        <xsl:copy>          
          <xsl:copy-of select="@* except @substitutionGroup"/>          
          <xsl:apply-templates mode="replace-substitution-groups"/>
        </xsl:copy>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy>          
          <xsl:copy-of select="@*"/>          
          <xsl:apply-templates mode="replace-substitution-groups"/>
        </xsl:copy>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for removing of some constructs that break UPA (Unique Particle Attribution rules in XSD).</doc:p>
      <doc:p>Currently only consecutive elements of same type are merged.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="remove-upa">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="remove-upa"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="xs:sequence" mode="remove-upa">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <!-- Group by @ref (we don't have types yet in schema). generate-id() is there just to provide grouping key for every node -->
      <xsl:for-each-group select="*" group-adjacent="(@ref, generate-id())[1]">
        <!-- WARNING: we are ignoring comments/text nodes in order to get grouping working -->
        <xsl:choose>
          <!-- No repeated elements with the same type, just copy -->
          <xsl:when test="count(current-group()) = 1">
            <xsl:apply-templates select="." mode="remove-upa"/>
          </xsl:when>
          <!-- Repeated element, merging and recalculating min/max-Occurs -->
          <xsl:otherwise>
            <xsl:copy>
              <xsl:copy-of select="@* except (@minOccurs | @maxOccurs)"/>
              <xsl:variable name="min-occurs" select="sum(current-group()/(if (@minOccurs) then @minOccurs else 1))"/>
              <xsl:variable name="max-occurs" select="sum(current-group()/(if (@maxOccurs) then @maxOccurs else 1))"/>
              <xsl:attribute name="minOccurs" select="$min-occurs"/>
              <xsl:attribute name="maxOccurs" select="$max-occurs"/>
              <xsl:if test="current-group()/@maxOccurs = 'unbounded'">
                <xsl:attribute name="maxOccurs">unbounded</xsl:attribute>
              </xsl:if>
            </xsl:copy>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each-group>
    </xsl:copy>
  </xsl:template>

  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for moving comments into annotations</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="comments-to-annotations">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="comments-to-annotations"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- By default, we remove all comments -->
  <xsl:template match="comment()" mode="comments-to-annotations" priority="10"/>
  
  <!-- Remove existing empty annotations -->
  <xsl:template match="xs:annotation[xs:documentation[not(text())]]" mode="comments-to-annotations"/>
  
  <!-- For elements that have preceding comments nodes fold them into annotation -->
  <xsl:template match="*[preceding-sibling::node()[not(self::text())][1]/self::comment()]" mode="comments-to-annotations">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xs:annotation>
        <xs:documentation xmlns="http://www.w3.org/1999/xhtml">
          <xsl:variable name="prev-element" select="preceding-sibling::*[1]"/>
          <xsl:for-each select="preceding-sibling::comment()[. >> $prev-element]">
            <xsl:for-each select="tokenize(., '\n')[normalize-space(.) != '']">
              <p><xsl:value-of select="normalize-space(.)"/></p>
            </xsl:for-each>
          </xsl:for-each>
        </xs:documentation>
        <!-- Copy existing documentation if there is any -->
        <xsl:copy-of select="xs:annotation/xs:documentation"/>
      </xs:annotation>
      <xsl:apply-templates select="node() except xs:annotation" mode="comments-to-annotations"/>
    </xsl:copy>
  </xsl:template>
    
  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for changing schema design. Overview of changes made into schema:</doc:p>
      <doc:ul>
        <doc:li>For each element corresponding type is created and used in element declaration.</doc:li>
        <doc:li>If element is not referenced from another namespaces then it's global declaration si removed .</doc:li>
        <doc:li>Global declaration for root element (cius) is preserved.</doc:li>        
      </doc:ul>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="remove-slices">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="remove-slices"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="xs:schema/xs:element[@name]" mode="remove-slices">
    <xsl:variable name="tns" select="ancestor::xs:schema/@targetNamespace"/>
    <xsl:variable name="qname" select="QName($tns, @name)"/>
    <xsl:variable name="referenced-from-namespaces" select="distinct-values(key('element-refs', $qname, /)/ancestor::xs:schema/@targetNamespace)"/>
    <xsl:variable name="keep-global-declaration" select="some $ns in $referenced-from-namespaces satisfies $ns != $tns"/>
    
    <!-- For some elements we must keep global declaration -->
    <xsl:if test="$keep-global-declaration or (@name = ('cius'))">
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:attribute name="type" select="concat(namespace::*[. = ancestor::xs:schema/@targetNamespace]/name(), ':', @name,'Type')"/>
        <xsl:apply-templates select="node() except xs:complexType" mode="remove-slices"/>
      </xsl:copy>
    </xsl:if>
    
    <!-- Emit named type declaration for element -->
    <xsl:choose>
      <xsl:when test="@type = 'c:html-rtf'">
        <xs:complexType>
          <xsl:attribute name="name" select="concat(@name, 'Type')"/>
          <!-- Annotations are moved into type declaration when element declaration is removed -->
          <xsl:apply-templates select="xs:annotation" mode="remove-slices"/>
          <xs:complexContent>
            <xs:extension base="c:html-rtf"/>
          </xs:complexContent>
        </xs:complexType>        
      </xsl:when>      
      <!-- If element used @type attribute, create simple type except for html-rtf type. (WARNING: in theory, there could be reference to complex type as well. -->
      <xsl:when test="@type">
        <xs:simpleType>
          <xsl:attribute name="name" select="concat(@name, 'Type')"/>
          <!-- Annotations are moved into type declaration when element declaration is removed -->
          <xsl:apply-templates select="xs:annotation" mode="remove-slices"/>
          <xs:restriction base="{@type}"/>
        </xs:simpleType>        
      </xsl:when>
      <!-- Otherwise copy all nested declarations -->
      <xsl:otherwise>
        <xsl:for-each select="*[not(self::xs:annotation)]">
          <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:if test="self::xs:complexType | self::xs:simpleType">
              <xsl:attribute name="name" select="concat(../@name, 'Type')"/>
              <!-- Annotations are moved into type declaration when element declaration is removed -->
              <xsl:apply-templates select="../xs:annotation" mode="remove-slices"/>              
            </xsl:if>
            <xsl:apply-templates mode="remove-slices"/>
          </xsl:copy>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- If the element has same target namespace as the schema then replace reference to global element declaration with type -->
  <xsl:template match="xs:element[@ref]" mode="remove-slices">
    <xsl:variable name="ref-qname" select="resolve-QName(@ref, .)"/>
    <xsl:variable name="ref-tns" select="namespace-uri-from-QName($ref-qname)"/>

    <xsl:copy>
      <xsl:copy-of select="@* except @ref"/>
      <xsl:choose>
        <xsl:when test="$ref-tns != ancestor::xs:schema/@targetNamespace">
          <xsl:copy-of select="@ref"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="name" select="local-name-from-QName($ref-qname)"/>
          <xsl:attribute name="type" select="concat(@ref, 'Type')"/>
        </xsl:otherwise>
      </xsl:choose>
      <!-- Copy annotation from the referenced element if there is no existing annotation -->
      <xsl:if test="not(xs:annotation)">
        <xsl:copy-of select="ancestor::xs:schema/xs:element[local-name-from-QName($ref-qname) = @name]/xs:annotation"/>  
      </xsl:if>      
      <xsl:apply-templates mode="remove-slices"/>
    </xsl:copy>
  </xsl:template>

  <!-- Handle nested local element declarations coming from substitution group -->
  <xsl:template match="xs:schema" mode="remove-slices">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="remove-slices"/>

      <!-- Create type definition from locally declared elements (they come from substitution groups replaced by xs:choice) -->
      <xsl:for-each-group select=".//xs:choice/xs:element[@name]" group-by="@name">
        
        <!-- For globaly declared element type declaration will be generated on the other place -->
        <xsl:if test="not(/xs:schema/xs:element[@name = current-grouping-key()])">
          <!-- Emit named type declaration for element -->
          <xsl:choose>      
            <!-- If element used @type attribute, create simple type. (WARNING: in theory, there could be reference to complex type as well. -->
            <xsl:when test="@type">
              <xs:simpleType>
                <xsl:attribute name="name" select="concat(@name, 'Type')"/>
                <xs:restriction base="{@type}"/>
              </xs:simpleType>        
            </xsl:when>
            <!-- Otherwise copy all nested declarations -->
            <xsl:otherwise>
              <xsl:for-each select="*[not(self::xs:annotation)]">
                <xsl:copy>
                  <xsl:copy-of select="@*"/>
                  <xsl:if test="self::xs:complexType | self::xs:simpleType">
                    <xsl:attribute name="name" select="concat(../@name, 'Type')"/>
                    <!-- Annotations are moved into type declaration when element declaration is removed -->
                    <xsl:apply-templates select="../xs:annotation" mode="remove-slices"/>              
                  </xsl:if>
                  <xsl:apply-templates mode="remove-slices"/>
                </xsl:copy>
              </xsl:for-each>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:for-each-group>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="xs:choice/xs:element[@name]" mode="remove-slices">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="type" select="concat(namespace::*[. = ancestor::xs:schema/@targetNamespace]/name(), ':', @name, 'Type')"/>
    </xsl:copy>
  </xsl:template>
  
  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for removing excessive xmlns:temp declarations</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="node()" mode="remove-temp-ns">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="remove-temp-ns"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="*" mode="remove-temp-ns" priority="10">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:copy-of select="namespace::*[not(name() = 'temp')]"/>
      <xsl:apply-templates mode="remove-temp-ns"/>
    </xsl:copy>
  </xsl:template>
  
  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Find type declaration for substitution group. Chained substitution groups are supported.</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:template name="copy-type">
    <xsl:param name="qname"/>
    
    <xsl:variable name="element" select="key('elements', $qname, $schema)"/>
    <xsl:variable name="local-type" select="$element/@type | $element/xs:complexType | $element/xs:simpleType"/>
    
    <xsl:choose>
      <!-- If element has type specified, then just copy it -->
      <xsl:when test="$local-type">
        <xsl:copy-of select="$local-type"/>
      </xsl:when>
      <!-- Otherwise try to get type declaration from substitution group head -->
      <xsl:when test="$element/@substitutionGroup">
        <xsl:message>Resolving type for chained substituion group <xsl:value-of select="$element/@substitutionGroup"/></xsl:message>
        <xsl:call-template name="copy-type">
          <xsl:with-param name="qname" select="resolve-QName($element/@substitutionGroup, $element)"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>Type declaration for <xsl:value-of select="name($element)"/> not found.</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <doc:doc scope="mode">		
    <doc:desc>
      <doc:p>Mode for recursively scanning all included/imported schema and returning URIs of such schemas.</doc:p>
      <doc:p>Breadth-first traversal with branch pruning is used to minimise stack and time used 
             (naive approach exponentially explodes with the current schemas).</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:template match="/" mode="get-schema-uris">
    <xsl:param name="known-uris" tunnel="yes" as="xs:string*"/>
    
    <xsl:variable name="new-uris" select="//(xs:include|xs:import)/@schemaLocation/resolve-uri(., base-uri())"/>
    <xsl:variable name="all-uris" select="distinct-values(($known-uris, $new-uris))"/>
    
    <xsl:for-each select="$new-uris">
      <xsl:if test="not(. = $known-uris)">
        <xsl:sequence select="."/>
        <xsl:apply-templates mode="get-schema-uris" select="doc(.)">
          <xsl:with-param name="known-uris" select="$all-uris" tunnel="yes"/>
        </xsl:apply-templates>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Function returns URI for writing schema into file for a particular namespace.</doc:p>
      <doc:p>URIs specified in the original schema are reused if possible.</doc:p>
    </doc:desc>
  </doc:doc>
  <xsl:function name="f:uri-for-tns" as="xs:string">
    <xsl:param name="schema"/>
    <xsl:param name="tns"/>
    
    <xsl:choose>
      <xsl:when test="$tns = 'urn:cen.eu:en16931:cius-extension:2018'">
        <xsl:sequence select="'ce-config.xsd'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="($schema//xs:import[@namespace = $tns])[1]/@schemaLocation"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Saves all schema files from $schema. $prefix is prepended before filename.</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:template name="save-schema">
    <xsl:param name="schema"/>
    <xsl:param name="prefix"/>

    <!-- Schemas are grouped by target namespace, so only one file for each namespace is emitted -->
    <xsl:for-each-group select="$schema//xs:schema" group-by="@targetNamespace">
      <xsl:variable name="tns" select="current-grouping-key()"/>
      <xsl:variable name="filename" select="f:uri-for-tns($schema, $tns)"/>
      <xsl:message>Writing schema for <xsl:value-of select="$tns"/> to <xsl:value-of select="$filename"/></xsl:message>
      <xsl:result-document href="{$prefix}{$filename}" indent="yes">
        <xs:schema>
          <xsl:for-each select="current-group()">
            <xsl:copy-of select="@* | namespace::*"/>
          </xsl:for-each>
          <!-- Imports are placed first -->              
          <xsl:for-each-group select="current-group()/xs:import" group-by="@schemaLocation">
            <xsl:copy>
              <xsl:copy-of select="@*"/>
              <xsl:attribute name="schemaLocation" select="f:uri-for-tns($schema, @namespace)"/>  
            </xsl:copy>                
          </xsl:for-each-group>
          <!-- Rest of schema components are written out, includes are ignored as we merged schema with the same target namespace -->
          <xsl:copy-of select="current-group()/node()[. except (self::xs:import | self::xs:include)]"/>
        </xs:schema>
      </xsl:result-document>
    </xsl:for-each-group>
    <!-- Write out master schema file referencing all other files -->
    <xsl:result-document href="{$prefix}/ce-config-main.xsd" indent="yes">
      <xs:schema>
        <xsl:copy-of select="$schema//xs:schema/namespace::*"/>
        <xsl:for-each-group select="$schema//xs:schema" group-by="@targetNamespace">
          <xsl:variable name="tns" select="current-grouping-key()"/>
          <xsl:variable name="filename" select="f:uri-for-tns($schema, $tns)"/>
          <xs:import namespace="{$tns}" schemaLocation="{$filename}"/>
        </xsl:for-each-group>
      </xs:schema>
    </xsl:result-document>
  </xsl:template>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Main template. No output is written to primary output.</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:template match="/">
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-without-temp-ns"/>
      <xsl:with-param name="prefix" select="'./'"/>
    </xsl:call-template>
  </xsl:template>

  <doc:doc scope="component">		
    <doc:desc>
      <doc:p>Debugging template. For each step intermediate schemas are written out.</doc:p>
    </doc:desc>
  </doc:doc>  
  <xsl:template name="debug">
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema"/>
      <xsl:with-param name="prefix">1/</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-without-substitution-groups"/>
      <xsl:with-param name="prefix">2/</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-without-broken-upa"/>
      <xsl:with-param name="prefix">3/</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-with-annotations"/>
      <xsl:with-param name="prefix">4/</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-without-slices"/>
      <xsl:with-param name="prefix">5/</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="save-schema">
      <xsl:with-param name="schema" select="$schema-without-temp-ns"/>
      <xsl:with-param name="prefix">6/</xsl:with-param>
    </xsl:call-template>
    <xsl:result-document href="substitution-groups-replacement.xml" indent="yes">
      <root>
        <xsl:copy-of select="$substitution-groups"/>
      </root>
    </xsl:result-document>    
  </xsl:template>
  
</xsl:stylesheet>